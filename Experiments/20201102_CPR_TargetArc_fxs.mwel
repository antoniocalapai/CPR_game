
//
// I/O Devices
//

stimulus_display 'Stimulus Display' (0, 0, 0)
iodevice/mio mIO (
    data_interval = 1ms
    joystick_direction = IO_joystickDirection
    joystick_strength = IO_joystickStrength
    joystick_x_raw = IO_joystickX_raw
    joystick_y_raw = IO_joystickY_raw
    joystick_x_calib = IO_joystickX_calib
    joystick_y_calib = IO_joystickY_calib
    reward_a = IO_rewardA
    )
iodevice/mouse_input mouse (
    mouse_position_x = IO_joystickX_calib
    mouse_position_y = IO_joystickY_calib
    mouse_down = IO_mouse_down
    hide_cursor = NO
    use_mirror_window = YES
    )

//
// Variables
//

group EXP {
    var EXP_task = 0
    var EXP_Xmax = 15.2024
    var EXP_Ymax = 11.4018
    var EXP_snr_min = .9
    var EXP_snr_max = 1
    var EXP_SteadyStateDuration = 0
    var EXP_Time2Target = 0
    var EXP_directionChange_list = [45,90,135,180]
    var EXP_RDPdir_change = 0
    var EXP_steadyState_min = 500
    var EXP_trial_duration = 0
    var EXP_trial_min = 10000
    var EXP_trial_max = 20000
    var EXP_ITI_ms = 1000
    var EXP_HoldTarget_ms = 500
    var EXP_start_area_colorChange_ms = 500
}
group IO {
    var IO_mouse_x = (float)(0)
    var IO_mouse_y = (float)(0)
    var IO_mouse_down = (float)(0)
    var IO_joystickDirection = (float)(0)
    var IO_joystickStrength = 0
    var IO_joystickX_raw = 0
    var IO_joystickY_raw = 0
    var IO_joystickX_calib = (float)(0)
    var IO_joystickY_calib = (float)(0)
    var IO_start_area_flag = 0
    var IO_start_area_size = 2
    var IO_start_area_col_r = 0
    var IO_start_area_col_g = 0
    var IO_start_area_col_b = 0
    var IO_rewardA = 0
    var IO_cursor_distance2center = 0
    var IO_cursor_accuracy = 0
    var IO_cursor_accuracyDisplay = 0
    var IO_cursor_x = 0
    var IO_cursor_y = 0
}
group Target {
    var IO_target_size = 2
    var IO_target_ON = 0
    var IO_target_duration = 1000
    var IO_target_flag = 0
    var IO_target_x = 0
    var IO_target_y = 9.25
    var IO_target_alpha = 0.5
    var IO_target_col_r = .5
    var IO_target_col_g = .5
    var IO_target_col_b = .5
    var IO_arc_width = 0
    var IO_arc_size = 20
    var IO_arc_flag = 0
    var IO_arc_alpha = 0
    var IO_arc_trigger_min = 0.5
    var IO_arc_trigger_max = 0.5
    var IO_arcMask_size = 17
    var IO_arcMask_flag = 0
    var IO_arc_col_r = 1
    var IO_arc_col_g = 1
    var IO_arc_col_b = 0
}
group TMP {
    var alpha = 0
    var pi = 3.14159265359
    var TMP_stimDir = 0
    var TMP_joyDeviation = 0
    var TMP_normStimDir = 0
    var TMP_normJoyDir = 0
    var TMP_scalingFactor = 0
    var dice = 0
    var steady_ts = 0
}
group RDP {
    var RDP_radius = 8
    var RDP_direction = 0
    var RDP_controlled_x = 0
    var RDP_target_x = 0
    var RDP_y = 0
    var RDP_x = 0
    var RDP_density = 5
    var RDP_dotsize = 0.2
    var RDP_speed = 3
    var RDP_coherence = 0
    var RDP_lifetime = 0.3
}
group ML {
    var ML_trialEnd = 0
    var ML_trialStart = 0
    var ML_sync = (bool)(0)
    var TRIAL_outcome = 0
}

//
// Sounds
//

wav_file Reward ('./sounds/reward.wav')

//
// Stimuli
//

blank_screen Background ()
circular_fixation_point start_area (
    color = IO_start_area_col_r,IO_start_area_col_g,IO_start_area_col_b
    trigger_width = IO_start_area_size
    trigger_watch_x = IO_cursor_x
    trigger_watch_y = IO_cursor_y
    trigger_flag = IO_start_area_flag
    x_size = IO_start_area_size
    y_size = IO_start_area_size
    x_position = 0
    y_position = 0
    rotation = 0
    alpha_multiplier = .3
    )
stimulus/r_d_p RDP (
    radius = RDP_radius
    x_position = RDP_x
    y_position = RDP_y
    dot_density = RDP_density
    dot_size = RDP_dotsize
    color = 1,1,1
    alpha_multiplier = 1.0
    direction = RDP_direction
    speed = RDP_speed
    coherence = RDP_coherence
    lifetime = RDP_lifetime
    announce_dots = NO
    autoplay = YES
    )
circular_fixation_point cursor (
    color = IO_arc_col_r,IO_arc_col_g,IO_arc_col_b
    trigger_width = 0
    trigger_watch_x = 0
    trigger_watch_y = 0
    trigger_flag = 0
    x_size = 1
    y_size = 1
    x_position = -EXP_Xmax * IO_joystickX_calib
    y_position = EXP_Ymax * IO_joystickY_calib
    rotation = 0
    alpha_multiplier = 1
    )
circular_fixation_point target (
    color = IO_target_col_r,IO_target_col_g,IO_target_col_b
    trigger_width = IO_target_size
    trigger_watch_x = IO_cursor_x
    trigger_watch_y = IO_cursor_y
    trigger_flag = IO_target_flag
    x_size = IO_target_size
    y_size = IO_target_size
    x_position = IO_target_x
    y_position = IO_target_y
    rotation = 0
    alpha_multiplier = IO_target_alpha
    )
stimulus/advstimulus arc (
    trigger_width = IO_arc_size
    trigger_watch_x = IO_target_x
    trigger_watch_y = IO_target_y
    trigger_flag = IO_arc_flag
    x_size = IO_arc_size
    y_size = IO_arc_size
    x_position = 0
    y_position = 0
    shape = format("circle %d", (integer)IO_arc_width)
    color = IO_arc_col_r,IO_arc_col_g,IO_arc_col_b
    rotation = -(IO_joystickDirection-90 - IO_arc_width/2)
    alpha_multiplier = IO_arc_alpha
    version = 1
    autoplay = YES
    )
circular_fixation_point arcMask (
    color = 0.5,0.5,0.5
    trigger_width = IO_arcMask_size
    trigger_watch_x = IO_cursor_x
    trigger_watch_y = IO_cursor_x
    trigger_flag = IO_arcMask_flag
    x_size = IO_arcMask_size
    y_size = IO_arcMask_size
    x_position = 0
    y_position = 0
    rotation = 0
    alpha_multiplier = 1
    )
text feedback_accuracy (
    text = format("Accuracy: %d", IO_cursor_accuracyDisplay)
    font_name = Arial
    font_size = 20
    color = 1,1,1
    x_size = 10
    y_size = 10
    x_position = -10
    y_position = 3
    rotation = 0
    alpha_multiplier = 1
    )
text feedback_distance (
    text = format("Dist2Center: %d", IO_cursor_distance2center)
    font_name = Arial
    font_size = 20
    color = 1,1,1
    x_size = 10
    y_size = 10
    x_position = -10
    y_position = 4
    rotation = 0
    alpha_multiplier = 1
    )

//
// Filters
//


//
// Optimizers
//


//
// Resources
//


//
// Protocols
//

protocol CPR_steady {
    start_device_io (mIO)
    start_device_io (mouse)
    live_queue_stimulus (Background)
    live_queue_stimulus (cursor)
    live_queue_stimulus (feedback_accuracy)
    live_queue_stimulus (feedback_distance)
    update_stimulus_display ()
    start_timer (
        timer = ColorChangeTimer
        duration = 0.0
        duration_units = ms
        )
    trial 'Trial structure' {
        task LOOP {
            state 'Wait for Joystick' {
                start_timer (
                    timer = FrameTimer
                    duration = 16
                    duration_units = ms
                    )
                if (1) {
                    IO_cursor_x = -(EXP_Xmax * IO_joystickX_calib)
                    IO_cursor_y = EXP_Ymax * IO_joystickY_calib
                }
                queue_stimulus (start_area)
                update_stimulus_display ()
                goto (
                    target = 'New Trial'
                    when = IO_start_area_flag == true
                    )
                timer_expired (
                    target = 'Wait for Joystick'
                    timer = FrameTimer
                    )
            }
            state 'New Trial' {
                if (1) {
                    ML_sync = 1
                    ML_trialStart = ML_trialStart + 1
                    EXP_task = "Steady_Flip"
                }
                if (1) {
                    RDP_direction = disc_rand(0,359)
                    RDP_speed = 4
                    RDP_coherence = rand(EXP_snr_min, EXP_snr_max)
                }
                update_stimulus_display ()
                EXP_trial_duration = disc_rand(EXP_trial_min, EXP_trial_max)
                start_timer (
                    timer = TrialTimer
                    duration = EXP_trial_duration
                    duration_units = ms
                    )
                report ('===== TRIAL $ML_trialStart STARTS=====')
                goto ('Show Stimuli')
            }
            state 'Show Stimuli' {
                if (1) {
                    live_queue_stimulus (arc)
                    live_queue_stimulus (arcMask)
                    live_queue_stimulus (RDP)
                    live_queue_stimulus (start_area)
                    live_queue_stimulus (cursor)
                    update_stimulus_display ()
                }
                goto ('Set up Target')
            }
            state 'Set up Target' {
                EXP_Time2Target = 1500 * disc_rand(1,6)
                start_timer (
                    timer = TargetTimer
                    duration = EXP_Time2Target
                    duration_units = ms
                    )
                goto ('Set up steady state')
            }
            state 'Set up steady state' {
                EXP_SteadyStateDuration = disc_rand(1000,3000)
                start_timer (
                    timer = SteadyStateDurationTimer
                    duration = EXP_SteadyStateDuration
                    duration_units = ms
                    )
                start_timer (
                    timer = SteadyStateMinDurationTimer
                    duration = EXP_steadyState_min
                    duration_units = ms
                    )
                steady_ts = now()
                goto ('Update Stimuli')
            }
            state 'Update Stimuli' {
                start_timer (
                    timer = FrameTimer
                    duration = 16
                    duration_units = ms
                    )
                if (timer_expired(ColorChangeTimer)) {
                    IO_start_area_col_g = 0
                }
                if (1) {
                    IO_cursor_x = -(EXP_Xmax * IO_joystickX_calib)
                    IO_cursor_y = EXP_Ymax * IO_joystickY_calib
                }
                if (1) {
                    IO_arc_trigger_min = (((TMP_stimDir - (IO_arc_width/2) + 360) % 360) + ((180-TMP_stimDir) + 360)) % 360
                    IO_arc_trigger_max = (((TMP_stimDir + (IO_arc_width/2) + 360) % 360) + ((180-TMP_stimDir) + 360)) % 360
                }
                if (1) {
                    alpha = RDP_direction
                    if (alpha >= 0 && alpha < 359) {
                        TMP_stimDir = alpha
                    }
                    if (alpha > 359) {
                        TMP_stimDir = alpha - 359
                    }
                    if (alpha < 0) {
                        TMP_stimDir = alpha + 359
                    }
                    IO_cursor_accuracy = abs(1 - abs(TMP_stimDir - (IO_joystickDirection - 90)) / 180)
                    IO_cursor_accuracyDisplay = round(IO_cursor_accuracy * 100) / 100
                }
                if (1) {
                    TMP_normJoyDir = (((IO_joystickDirection-90) + (180-TMP_stimDir) + 360) % 360) 
                    TMP_normStimDir = (((TMP_stimDir + 360) % 360) + ((180-TMP_stimDir) + 360)) % 360
                    TMP_joyDeviation = abs(TMP_normJoyDir - TMP_normStimDir)
                    IO_cursor_distance2center = sqrt(pow(IO_cursor_y,2) + pow(IO_cursor_x,2))
                }
                if (1) {
                    if (IO_cursor_distance2center <= RDP_radius) {
                        TMP_scalingFactor = IO_cursor_distance2center
                    }
                    if (IO_cursor_distance2center > RDP_radius) {
                        TMP_scalingFactor = RDP_radius
                    }
                    IO_arc_width = 180 * (abs(TMP_scalingFactor - RDP_radius)/RDP_radius)
                }
                if (1) {
                    IO_arc_alpha = IO_cursor_distance2center / RDP_radius
                    IO_target_alpha = IO_cursor_distance2center / RDP_radius
                }
                update_stimulus_display ()
                timer_expired (
                    target = 'Direction switch'
                    timer = SteadyStateDurationTimer
                    )
                goto (
                    target = 'Target presentation'
                    when = timer_expired(TargetTimer) && timer_expired(SteadyStateMinDurationTimer)
                    )
                timer_expired (
                    target = 'End Trial'
                    timer = TrialTimer
                    )
                timer_expired (
                    target = 'Update Stimuli'
                    timer = FrameTimer
                    )
            }
            state 'Direction switch' {
                dice = disc_rand(0,1)
                EXP_RDPdir_change =  EXP_directionChange_list[disc_rand(0,3)]
                if (dice == 1) {
                    RDP_direction = RDP_direction + EXP_RDPdir_change
                }
                if (dice == 0) {
                    RDP_direction = RDP_direction - EXP_RDPdir_change
                }
                goto ('Set up steady state')
            }
            state 'Target presentation' {
                if (1) {
                    IO_target_x = sin((RDP_direction)*(pi/180))*(RDP_radius + (IO_target_size/2))
                    IO_target_y = cos((RDP_direction)*(pi/180))*(RDP_radius+ (IO_target_size/2))
                }
                live_queue_stimulus (target)
                IO_target_ON = 1
                start_timer (
                    timer = TargetDurationTimer
                    duration = IO_target_duration
                    duration_units = ms
                    )
                report ('--- SHOW TARGET ---')
                goto ('Check if target detected')
            }
            state 'Check if target detected' {
                start_timer (
                    timer = FrameTimer
                    duration = 16
                    duration_units = ms
                    )
                if (IO_start_area_col_g == 1) {
                    IO_start_area_col_g = 0
                }
                if (1) {
                    IO_cursor_x = -(EXP_Xmax * IO_joystickX_calib)
                    IO_cursor_y = EXP_Ymax * IO_joystickY_calib
                }
                if (1) {
                    IO_arc_trigger_min = (((TMP_stimDir - (IO_arc_width/2) + 360) % 360) + ((180-TMP_stimDir) + 360)) % 360
                    IO_arc_trigger_max = (((TMP_stimDir + (IO_arc_width/2) + 360) % 360) + ((180-TMP_stimDir) + 360)) % 360
                }
                if (1) {
                    alpha = RDP_direction
                    if (alpha >= 0 && alpha < 359) {
                        TMP_stimDir = alpha
                    }
                    if (alpha > 359) {
                        TMP_stimDir = alpha - 359
                    }
                    if (alpha < 0) {
                        TMP_stimDir = alpha + 359
                    }
                    IO_cursor_accuracy = abs(1 - abs(TMP_stimDir - (IO_joystickDirection - 90)) / 180)
                    IO_cursor_accuracyDisplay = round(IO_cursor_accuracy * 100) / 100
                }
                if (1) {
                    TMP_normJoyDir = (((IO_joystickDirection-90) + (180-TMP_stimDir) + 360) % 360) 
                    TMP_normStimDir = (((TMP_stimDir + 360) % 360) + ((180-TMP_stimDir) + 360)) % 360
                    TMP_joyDeviation = abs(TMP_normJoyDir - TMP_normStimDir)
                    IO_cursor_distance2center = sqrt(pow(IO_cursor_y,2) + pow(IO_cursor_x,2))
                }
                if (1) {
                    if (IO_cursor_distance2center <= RDP_radius) {
                        TMP_scalingFactor = IO_cursor_distance2center
                    }
                    if (IO_cursor_distance2center > RDP_radius) {
                        TMP_scalingFactor = RDP_radius
                    }
                    IO_arc_width = 180 * (abs(TMP_scalingFactor - RDP_radius)/RDP_radius)
                }
                if (1) {
                    IO_arc_alpha = IO_cursor_distance2center / RDP_radius
                    IO_target_alpha = IO_cursor_distance2center / RDP_radius
                }
                if (1) {
                    IO_arc_flag = (TMP_normJoyDir >= IO_arc_trigger_min) && (TMP_normJoyDir <=IO_arc_trigger_max)
                    if (IO_arc_flag) {
                        IO_target_col_r = 0
                        IO_target_col_g = 0
                        IO_target_col_b = 0
                    }
                    if (IO_arc_flag == false) {
                        IO_target_col_r = 0.5
                        IO_target_col_g = 0.5
                        IO_target_col_b = 0.5
                    }
                }
                update_stimulus_display ()
                start_timer (
                    timer = HoldDurationTimer
                    duration = EXP_HoldTarget_ms
                    duration_units = ms
                    )
                goto (
                    target = 'Hold target'
                    when = IO_arc_flag
                    )
                timer_expired (
                    target = Miss
                    timer = TargetDurationTimer
                    )
                timer_expired (
                    target = 'Check if target detected'
                    timer = FrameTimer
                    )
            }
            state 'Hold target' {
                start_timer (
                    timer = FrameTimer
                    duration = 16
                    duration_units = ms
                    )
                if (1) {
                    IO_cursor_x = -(EXP_Xmax * IO_joystickX_calib)
                    IO_cursor_y = EXP_Ymax * IO_joystickY_calib
                }
                if (1) {
                    IO_arc_trigger_min = (((TMP_stimDir - (IO_arc_width/2) + 360) % 360) + ((180-TMP_stimDir) + 360)) % 360
                    IO_arc_trigger_max = (((TMP_stimDir + (IO_arc_width/2) + 360) % 360) + ((180-TMP_stimDir) + 360)) % 360
                }
                if (1) {
                    alpha = RDP_direction
                    if (alpha >= 0 && alpha < 359) {
                        TMP_stimDir = alpha
                    }
                    if (alpha > 359) {
                        TMP_stimDir = alpha - 359
                    }
                    if (alpha < 0) {
                        TMP_stimDir = alpha + 359
                    }
                    IO_cursor_accuracy = abs(1 - abs(TMP_stimDir - (IO_joystickDirection - 90)) / 180)
                    IO_cursor_accuracyDisplay = round(IO_cursor_accuracy * 100) / 100
                }
                if (1) {
                    TMP_normJoyDir = (((IO_joystickDirection-90) + (180-TMP_stimDir) + 360) % 360) 
                    TMP_normStimDir = (((TMP_stimDir + 360) % 360) + ((180-TMP_stimDir) + 360)) % 360
                    TMP_joyDeviation = abs(TMP_normJoyDir - TMP_normStimDir)
                    IO_cursor_distance2center = sqrt(pow(IO_cursor_y,2) + pow(IO_cursor_x,2))
                }
                if (1) {
                    if (IO_cursor_distance2center <= RDP_radius) {
                        TMP_scalingFactor = IO_cursor_distance2center
                    }
                    if (IO_cursor_distance2center > RDP_radius) {
                        TMP_scalingFactor = RDP_radius
                    }
                    IO_arc_width = 180 * (abs(TMP_scalingFactor - RDP_radius)/RDP_radius)
                }
                if (1) {
                    IO_arc_alpha = IO_cursor_distance2center / RDP_radius
                    IO_target_alpha = IO_cursor_distance2center / RDP_radius
                }
                if (1) {
                    IO_arc_flag = (TMP_normJoyDir >= IO_arc_trigger_min) && (TMP_normJoyDir <=IO_arc_trigger_max)
                    if (IO_arc_flag) {
                        IO_target_col_r = 0
                        IO_target_col_g = 0
                        IO_target_col_b = 0
                    }
                    if (IO_arc_flag == false) {
                        IO_target_col_r = 0.5
                        IO_target_col_g = 0.5
                        IO_target_col_b = 0.5
                    }
                }
                update_stimulus_display ()
                goto (
                    target = Hit
                    when = IO_arc_flag && timer_expired(HoldDurationTimer)
                    )
                goto (
                    target = 'Check if target detected'
                    when = IO_arc_flag == false
                    )
                timer_expired (
                    target = 'Hold target'
                    timer = FrameTimer
                    )
            }
            state Miss {
                dequeue_stimulus (target)
                update_stimulus_display ()
                IO_target_ON = 0
                TRIAL_outcome = "miss"
                report ('--- OUTCOME: Miss ---')
                goto ('Set up Target')
            }
            state Hit {
                play_sound (Reward)
                dequeue_stimulus (target)
                update_stimulus_display ()
                IO_target_ON = 0
                TRIAL_outcome = "hit"
                report ('--- OUTCOME: Hit ---')
                IO_start_area_col_g = 1
                start_timer (
                    timer = ColorChangeTimer
                    duration = EXP_start_area_colorChange_ms
                    duration_units = ms
                    )
                goto ('Set up Target')
            }
            state 'End Trial' {
                if (1) {
                    dequeue_stimulus (target)
                    dequeue_stimulus (RDP)
                    dequeue_stimulus (start_area)
                    dequeue_stimulus (arc)
                    dequeue_stimulus (arcMask)
                }
                IO_start_area_col_g = 0
                update_stimulus_display ()
                if (1) {
                    ML_sync = 0
                    ML_trialEnd = ML_trialEnd + 1
                }
                report ('===== TRIAL $ML_trialEnd ENDS=====')
                start_timer (
                    timer = ITI_Timer
                    duration = EXP_ITI_ms
                    duration_units = ms
                    )
                goto (ITI)
            }
            state ITI {
                start_timer (
                    timer = FrameTimer
                    duration = 16
                    duration_units = ms
                    )
                if (1) {
                    IO_cursor_x = -(EXP_Xmax * IO_joystickX_calib)
                    IO_cursor_y = EXP_Ymax * IO_joystickY_calib
                }
                timer_expired (
                    target = 'Wait for Joystick'
                    timer = ITI_Timer
                    )
                timer_expired (
                    target = ITI
                    timer = FrameTimer
                    )
            }
        }
    }
}
